
#include <cstdlib>
#include <cstdio>
#include "parser.h"

// Generated by json-cpp-gen by Viktor Chlumsky
// https://github.com/Chlumsky/json-cpp-gen

namespace octopus {

ManifestParser::Error::operator ManifestParser::ErrorType() const {
    return type;
}

ManifestParser::Error::operator bool() const {
    return type != ErrorType::OK;
}

const char *ManifestParser::Error::typeString() const {
    switch (type) {
        case ErrorType::OK:
            return "OK";
        case ErrorType::JSON_SYNTAX_ERROR:
            return "JSON_SYNTAX_ERROR";
        case ErrorType::UNEXPECTED_END_OF_FILE:
            return "UNEXPECTED_END_OF_FILE";
        case ErrorType::TYPE_MISMATCH:
            return "TYPE_MISMATCH";
        case ErrorType::ARRAY_SIZE_MISMATCH:
            return "ARRAY_SIZE_MISMATCH";
        case ErrorType::UNKNOWN_KEY:
            return "UNKNOWN_KEY";
        case ErrorType::UNKNOWN_ENUM_VALUE:
            return "UNKNOWN_ENUM_VALUE";
        case ErrorType::VALUE_OUT_OF_RANGE:
            return "VALUE_OUT_OF_RANGE";
        case ErrorType::STRING_EXPECTED:
            return "STRING_EXPECTED";
        case ErrorType::UTF16_ENCODING_ERROR:
            return "UTF16_ENCODING_ERROR";
    }
    return "";
}

ManifestParser::ManifestParser(const char *str) : cur(str) { }

void ManifestParser::skipWhitespace() {
    while (*cur == ' ' || *cur == '\t' || *cur == '\r' || *cur == '\n')
        ++cur;
}

ManifestParser::ErrorType ManifestParser::skipValue() {
    skipWhitespace();
    switch (*cur) {
        case '\0':
            return ErrorType::UNEXPECTED_END_OF_FILE;
        case '"':
            while (*++cur != '"') {
                if (!*(cur += *cur == '\\'))
                    return ErrorType::UNEXPECTED_END_OF_FILE;
            }
            ++cur;
            return ErrorType::OK;
        case '[': case '{':
            ++cur;
            for (int openBrackets = 1; openBrackets;) {
                switch (*cur) {
                    case '\0':
                        return ErrorType::UNEXPECTED_END_OF_FILE;
                    case '"':
                        if (ErrorType error = skipValue())
                            return error;
                        continue;
                    case '[': case '{':
                        ++openBrackets;
                        break;
                    case ']': case '}':
                        --openBrackets;
                        break;
                }
                ++cur;
            }
            return ErrorType::OK;
        default:
            if (isAlphanumeric(*cur) || *cur == '-' || *cur == '.') {
                while (isAlphanumeric(*++cur) || *cur == '+' || *cur == '-' || *cur == '.');
                return ErrorType::OK;
            }
    }
    return ErrorType::JSON_SYNTAX_ERROR;
}

bool ManifestParser::matchSymbol(char s) {
    skipWhitespace();
    if (*cur == s) {
        ++cur;
        return true;
    }
    return false;
}

ManifestParser::ErrorType ManifestParser::unescape(char *codepoints) {
    switch (*++cur) {
        case '\0':
            return ErrorType::UNEXPECTED_END_OF_FILE;
        case 'B': case 'b': codepoints[0] = '\b'; break;
        case 'F': case 'f': codepoints[0] = '\f'; break;
        case 'N': case 'n': codepoints[0] = '\n'; break;
        case 'R': case 'r': codepoints[0] = '\r'; break;
        case 'T': case 't': codepoints[0] = '\t'; break;
        case 'U': case 'u': {
            unsigned long cp;
            unsigned short wc;
            ++cur;
            if (!(cur[0] && cur[1] && cur[2] && cur[3]))
                return ErrorType::JSON_SYNTAX_ERROR;
            codepoints[0] = cur[0], codepoints[1] = cur[1], codepoints[2] = cur[2], codepoints[3] = cur[3];
            codepoints[4] = '\0';
            cur += 3;
            if (sscanf(codepoints, "%hx", &wc) != 1)
                return ErrorType::JSON_SYNTAX_ERROR;
            if ((wc&0xfc00) == 0xd800) {
                if (!(cur[1] == '\\' && (cur[2] == 'u' || cur[2] == 'U')))
                    return ErrorType::UTF16_ENCODING_ERROR;
                cp = (unsigned long) (wc&0x03ff)<<10;
                cur += 3;
                if (!(cur[0] && cur[1] && cur[2] && cur[3]))
                    return ErrorType::JSON_SYNTAX_ERROR;
                codepoints[0] = cur[0], codepoints[1] = cur[1], codepoints[2] = cur[2], codepoints[3] = cur[3];
                codepoints[4] = '\0';
                cur += 3;
                if (sscanf(codepoints, "%hx", &wc) != 1)
                    return ErrorType::JSON_SYNTAX_ERROR;
                if ((wc&0xfc00) != 0xdc00)
                    return ErrorType::UTF16_ENCODING_ERROR;
                cp = 0x010000+(cp|(unsigned long) (wc&0x03ff));
            } else
                cp = wc;
            if (cp&0xffffff80) {
                int len;
                for (len = 1; cp>>(5*len+1) && len < 6; ++len);
                codepoints[0] = (char) (0xff<<(8-len)|cp>>6*(len-1));
                for (int i = 1; i < len; ++i)
                    *++codepoints = (char) (0x80|(cp>>6*(len-i-1)&0x3f));
            } else
                codepoints[0] = (char) cp;
            break;
        }
        default:
            codepoints[0] = *cur;
    }
    codepoints[1] = '\0';
    return ErrorType::OK;
}

bool ManifestParser::isAlphanumeric(char c) {
    switch (c) {
        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G': case 'H': case 'I':
        case 'J': case 'K': case 'L': case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':
        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X': case 'Y': case 'Z':
        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g': case 'h': case 'i':
        case 'j': case 'k': case 'l': case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':
        case 's': case 't': case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':
        case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
            return true;
        default:
            return false;
    }
}

template <typename T>
ManifestParser::ErrorType ManifestParser::readSigned(T &value) {
    bool negative = *cur == '-' && (++cur, true);
    if (*cur >= '0' && *cur <= '9')
        value = *cur++-'0';
    else
        return ErrorType::TYPE_MISMATCH;
    while (*cur >= '0' && *cur <= '9') {
        if (10*value < value)
            return ErrorType::VALUE_OUT_OF_RANGE;
        value = 10*value+(*cur++-'0');
    }
    if (negative)
        value = -value;
    return ErrorType::OK;
}

ManifestParser::Error ManifestParser::parse(octopus::OctopusManifest &output, const char *jsonString) {
    ManifestParser parser(jsonString);
    ErrorType error = parser.parseOctopusOctopusManifest(output);
    return Error(error, static_cast<int>(parser.cur-jsonString));
}

ManifestParser::ErrorType ManifestParser::parseStdString(std::string &value) {
    skipWhitespace();
    if (*cur != '"')
        return ErrorType::STRING_EXPECTED;
    value.clear();
    while (*++cur != '"') {
        if (*cur == '\\') {
            char buffer[8];
            if (Error error = unescape(buffer))
                return error;
            value += buffer;
            continue;
        }
        if (!*cur)
            return ErrorType::UNEXPECTED_END_OF_FILE;
        value.push_back(*cur);
    }
    ++cur;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusOctopusManifestOrigin(octopus::OctopusManifest::Origin &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (key == "name") {
            if (Error error = parseStdString(value.name))
                return error;
        } else if (key == "version") {
            if (Error error = parseStdString(value.version))
                return error;
        } else {
            if (Error error = skipValue())
                return error;
        }
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusReferenceType(octopus::Reference::Type &value) {
    std::string str;
    if (ErrorType error = parseStdString(str))
        return error;
    if (str == "CHUNK")
        value = octopus::Reference::Type::CHUNK;
    else if (str == "COMPONENT")
        value = octopus::Reference::Type::COMPONENT;
    else if (str == "ARTBOARD")
        value = octopus::Reference::Type::ARTBOARD;
    else
        return ErrorType::UNKNOWN_ENUM_VALUE;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusReference(octopus::Reference &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (key == "type") {
            if (Error error = parseOctopusReferenceType(value.type))
                return error;
        } else if (key == "id") {
            if (Error error = parseStdString(value.id))
                return error;
        } else {
            if (Error error = skipValue())
                return error;
        }
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseStdVectorOctopusReference(std::vector<octopus::Reference> &value) {
    if (!matchSymbol('['))
        return ErrorType::TYPE_MISMATCH;
    value.clear();
    int separatorCheck = -1;
    while (!matchSymbol(']')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseOctopusReference((value.emplace_back(), value.back())))
            return error;
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseNonstdOptionalStdString(nonstd::optional<std::string> &value) {
    skipWhitespace();
    if (cur[0] == 'n' && cur[1] == 'u' && cur[2] == 'l' && cur[3] == 'l' && !isAlphanumeric(cur[4]) && cur[4] != '_' && ((cur += 4), true))
        value.reset();
    else if (Error error = parseStdString((value = std::string()).value()))
        return error;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusPage(octopus::Page &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (key == "id") {
            if (Error error = parseStdString(value.id))
                return error;
        } else if (key == "name") {
            if (Error error = parseStdString(value.name))
                return error;
        } else if (key == "children") {
            if (Error error = parseStdVectorOctopusReference(value.children))
                return error;
        } else if (key == "description") {
            if (Error error = parseNonstdOptionalStdString(value.description))
                return error;
        } else if (key == "hash") {
            if (Error error = parseNonstdOptionalStdString(value.hash))
                return error;
        } else {
            if (Error error = skipValue())
                return error;
        }
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseStdVectorOctopusPage(std::vector<octopus::Page> &value) {
    if (!matchSymbol('['))
        return ErrorType::TYPE_MISMATCH;
    value.clear();
    int separatorCheck = -1;
    while (!matchSymbol(']')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseOctopusPage((value.emplace_back(), value.back())))
            return error;
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusComponentRole(octopus::Component::Role &value) {
    std::string str;
    if (ErrorType error = parseStdString(str))
        return error;
    if (str == "COMPONENT")
        value = octopus::Component::Role::COMPONENT;
    else if (str == "ARTBOARD")
        value = octopus::Component::Role::ARTBOARD;
    else if (str == "PASTEBOARD")
        value = octopus::Component::Role::PASTEBOARD;
    else if (str == "PARTIAL")
        value = octopus::Component::Role::PARTIAL;
    else
        return ErrorType::UNKNOWN_ENUM_VALUE;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseDouble(double &value) {
    char *end;
    value = strtod(cur, &end);
    if (end == cur)
        return ErrorType::TYPE_MISMATCH;
    cur = end;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusBounds(octopus::Bounds &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (key == "x") {
            if (Error error = parseDouble(value.x))
                return error;
        } else if (key == "y") {
            if (Error error = parseDouble(value.y))
                return error;
        } else if (key == "width") {
            if (Error error = parseDouble(value.width))
                return error;
        } else if (key == "height") {
            if (Error error = parseDouble(value.height))
                return error;
        } else {
            if (Error error = skipValue())
                return error;
        }
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusResourceLocationType(octopus::ResourceLocation::Type &value) {
    std::string str;
    if (ErrorType error = parseStdString(str))
        return error;
    if (str == "RELATIVE")
        value = octopus::ResourceLocation::Type::RELATIVE;
    else if (str == "EXTERNAL")
        value = octopus::ResourceLocation::Type::EXTERNAL;
    else
        return ErrorType::UNKNOWN_ENUM_VALUE;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusResourceLocation(octopus::ResourceLocation &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (key == "type") {
            if (Error error = parseOctopusResourceLocationType(value.type))
                return error;
        } else if (key == "path") {
            if (Error error = parseNonstdOptionalStdString(value.path))
                return error;
        } else if (key == "url") {
            if (Error error = parseNonstdOptionalStdString(value.url))
                return error;
        } else if (key == "versionHash") {
            if (Error error = parseNonstdOptionalStdString(value.versionHash))
                return error;
        } else {
            if (Error error = skipValue())
                return error;
        }
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusArtifactType(octopus::Artifact::Type &value) {
    std::string str;
    if (ErrorType error = parseStdString(str))
        return error;
    if (str == "OCTOPUS")
        value = octopus::Artifact::Type::OCTOPUS;
    else if (str == "OCTOPUS_EXPANDED")
        value = octopus::Artifact::Type::OCTOPUS_EXPANDED;
    else if (str == "SOURCE")
        value = octopus::Artifact::Type::SOURCE;
    else
        return ErrorType::UNKNOWN_ENUM_VALUE;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusArtifact(octopus::Artifact &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (key == "type") {
            if (Error error = parseOctopusArtifactType(value.type))
                return error;
        } else if (key == "location") {
            if (Error error = parseOctopusResourceLocation(value.location))
                return error;
        } else {
            if (Error error = skipValue())
                return error;
        }
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseStdVectorOctopusArtifact(std::vector<octopus::Artifact> &value) {
    if (!matchSymbol('['))
        return ErrorType::TYPE_MISMATCH;
    value.clear();
    int separatorCheck = -1;
    while (!matchSymbol(']')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseOctopusArtifact((value.emplace_back(), value.back())))
            return error;
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseNonstdOptionalOctopusReference(nonstd::optional<octopus::Reference> &value) {
    skipWhitespace();
    if (cur[0] == 'n' && cur[1] == 'u' && cur[2] == 'l' && cur[3] == 'l' && !isAlphanumeric(cur[4]) && cur[4] != '_' && ((cur += 4), true))
        value.reset();
    else if (Error error = parseOctopusReference((value = octopus::Reference()).value()))
        return error;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseNonstdOptionalOctopusResourceLocation(nonstd::optional<octopus::ResourceLocation> &value) {
    skipWhitespace();
    if (cur[0] == 'n' && cur[1] == 'u' && cur[2] == 'l' && cur[3] == 'l' && !isAlphanumeric(cur[4]) && cur[4] != '_' && ((cur += 4), true))
        value.reset();
    else if (Error error = parseOctopusResourceLocation((value = octopus::ResourceLocation()).value()))
        return error;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusAssetFont(octopus::AssetFont &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (key == "location") {
            if (Error error = parseNonstdOptionalOctopusResourceLocation(value.location))
                return error;
        } else if (key == "fontType") {
            if (Error error = parseNonstdOptionalStdString(value.fontType))
                return error;
        } else if (key == "refId") {
            if (Error error = parseStdString(value.refId))
                return error;
        } else if (key == "name") {
            if (Error error = parseStdString(value.name))
                return error;
        } else {
            if (Error error = skipValue())
                return error;
        }
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseStdVectorOctopusAssetFont(std::vector<octopus::AssetFont> &value) {
    if (!matchSymbol('['))
        return ErrorType::TYPE_MISMATCH;
    value.clear();
    int separatorCheck = -1;
    while (!matchSymbol(']')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseOctopusAssetFont((value.emplace_back(), value.back())))
            return error;
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusAssetImage(octopus::AssetImage &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (key == "location") {
            if (Error error = parseOctopusResourceLocation(value.location))
                return error;
        } else if (key == "refId") {
            if (Error error = parseStdString(value.refId))
                return error;
        } else if (key == "name") {
            if (Error error = parseStdString(value.name))
                return error;
        } else {
            if (Error error = skipValue())
                return error;
        }
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseStdVectorOctopusAssetImage(std::vector<octopus::AssetImage> &value) {
    if (!matchSymbol('['))
        return ErrorType::TYPE_MISMATCH;
    value.clear();
    int separatorCheck = -1;
    while (!matchSymbol(']')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseOctopusAssetImage((value.emplace_back(), value.back())))
            return error;
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusAssets(octopus::Assets &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (key == "fonts") {
            if (Error error = parseStdVectorOctopusAssetFont(value.fonts))
                return error;
        } else if (key == "images") {
            if (Error error = parseStdVectorOctopusAssetImage(value.images))
                return error;
        } else {
            if (Error error = skipValue())
                return error;
        }
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseNonstdOptionalOctopusAssets(nonstd::optional<octopus::Assets> &value) {
    skipWhitespace();
    if (cur[0] == 'n' && cur[1] == 'u' && cur[2] == 'l' && cur[3] == 'l' && !isAlphanumeric(cur[4]) && cur[4] != '_' && ((cur += 4), true))
        value.reset();
    else if (Error error = parseOctopusAssets((value = octopus::Assets()).value()))
        return error;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusComponentSet(octopus::ComponentSet &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (key == "id") {
            if (Error error = parseStdString(value.id))
                return error;
        } else if (key == "name") {
            if (Error error = parseStdString(value.name))
                return error;
        } else if (key == "description") {
            if (Error error = parseNonstdOptionalStdString(value.description))
                return error;
        } else {
            if (Error error = skipValue())
                return error;
        }
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseStdMapStdStringStdString(std::map<std::string, std::string> &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    value.clear();
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(value[key]))
            return error;
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusComponentVariantMeta(octopus::Component::VariantMeta &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (key == "of") {
            if (Error error = parseOctopusComponentSet(value.of))
                return error;
        } else if (key == "properties") {
            if (Error error = parseStdMapStdStringStdString(value.properties))
                return error;
        } else if (key == "description") {
            if (Error error = parseNonstdOptionalStdString(value.description))
                return error;
        } else {
            if (Error error = skipValue())
                return error;
        }
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseNonstdOptionalOctopusComponentVariantMeta(nonstd::optional<octopus::Component::VariantMeta> &value) {
    skipWhitespace();
    if (cur[0] == 'n' && cur[1] == 'u' && cur[2] == 'l' && cur[3] == 'l' && !isAlphanumeric(cur[4]) && cur[4] != '_' && ((cur += 4), true))
        value.reset();
    else if (Error error = parseOctopusComponentVariantMeta((value = octopus::Component::VariantMeta()).value()))
        return error;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusStatusValue(octopus::Status::Value &value) {
    std::string str;
    if (ErrorType error = parseStdString(str))
        return error;
    if (str == "READY")
        value = octopus::Status::Value::READY;
    else if (str == "PENDING")
        value = octopus::Status::Value::PENDING;
    else if (str == "PROCESSING")
        value = octopus::Status::Value::PROCESSING;
    else if (str == "FAILED")
        value = octopus::Status::Value::FAILED;
    else
        return ErrorType::UNKNOWN_ENUM_VALUE;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseInt(int &value) {
    skipWhitespace();
    return readSigned(value);
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseStdVectorStdString(std::vector<std::string> &value) {
    if (!matchSymbol('['))
        return ErrorType::TYPE_MISMATCH;
    value.clear();
    int separatorCheck = -1;
    while (!matchSymbol(']')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString((value.emplace_back(), value.back())))
            return error;
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusStatusError(octopus::Status::Error &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (key == "code") {
            if (Error error = parseInt(value.code))
                return error;
        } else if (key == "message") {
            if (Error error = parseStdString(value.message))
                return error;
        } else if (key == "stacktrace") {
            if (Error error = parseStdVectorStdString(value.stacktrace))
                return error;
        } else {
            if (Error error = skipValue())
                return error;
        }
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseNonstdOptionalOctopusStatusError(nonstd::optional<octopus::Status::Error> &value) {
    skipWhitespace();
    if (cur[0] == 'n' && cur[1] == 'u' && cur[2] == 'l' && cur[3] == 'l' && !isAlphanumeric(cur[4]) && cur[4] != '_' && ((cur += 4), true))
        value.reset();
    else if (Error error = parseOctopusStatusError((value = octopus::Status::Error()).value()))
        return error;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseNonstdOptionalDouble(nonstd::optional<double> &value) {
    skipWhitespace();
    if (cur[0] == 'n' && cur[1] == 'u' && cur[2] == 'l' && cur[3] == 'l' && !isAlphanumeric(cur[4]) && cur[4] != '_' && ((cur += 4), true))
        value.reset();
    else if (Error error = parseDouble((value = double()).value()))
        return error;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusStatus(octopus::Status &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (key == "value") {
            if (Error error = parseOctopusStatusValue(value.value))
                return error;
        } else if (key == "error") {
            if (Error error = parseNonstdOptionalOctopusStatusError(value.error))
                return error;
        } else if (key == "time") {
            if (Error error = parseNonstdOptionalDouble(value.time))
                return error;
        } else {
            if (Error error = skipValue())
                return error;
        }
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseNonstdOptionalOctopusStatus(nonstd::optional<octopus::Status> &value) {
    skipWhitespace();
    if (cur[0] == 'n' && cur[1] == 'u' && cur[2] == 'l' && cur[3] == 'l' && !isAlphanumeric(cur[4]) && cur[4] != '_' && ((cur += 4), true))
        value.reset();
    else if (Error error = parseOctopusStatus((value = octopus::Status()).value()))
        return error;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusComponent(octopus::Component &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (key == "id") {
            if (Error error = parseStdString(value.id))
                return error;
        } else if (key == "name") {
            if (Error error = parseStdString(value.name))
                return error;
        } else if (key == "role") {
            if (Error error = parseOctopusComponentRole(value.role))
                return error;
        } else if (key == "bounds") {
            if (Error error = parseOctopusBounds(value.bounds))
                return error;
        } else if (key == "dependencies") {
            if (Error error = parseStdVectorOctopusReference(value.dependencies))
                return error;
        } else if (key == "location") {
            if (Error error = parseOctopusResourceLocation(value.location))
                return error;
        } else if (key == "artifacts") {
            if (Error error = parseStdVectorOctopusArtifact(value.artifacts))
                return error;
        } else if (key == "parentId") {
            if (Error error = parseNonstdOptionalOctopusReference(value.parentId))
                return error;
        } else if (key == "preview") {
            if (Error error = parseNonstdOptionalOctopusResourceLocation(value.preview))
                return error;
        } else if (key == "assets") {
            if (Error error = parseNonstdOptionalOctopusAssets(value.assets))
                return error;
        } else if (key == "variant") {
            if (Error error = parseNonstdOptionalOctopusComponentVariantMeta(value.variant))
                return error;
        } else if (key == "description") {
            if (Error error = parseNonstdOptionalStdString(value.description))
                return error;
        } else if (key == "hash") {
            if (Error error = parseNonstdOptionalStdString(value.hash))
                return error;
        } else if (key == "status") {
            if (Error error = parseNonstdOptionalOctopusStatus(value.status))
                return error;
        } else {
            if (Error error = skipValue())
                return error;
        }
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseStdVectorOctopusComponent(std::vector<octopus::Component> &value) {
    if (!matchSymbol('['))
        return ErrorType::TYPE_MISMATCH;
    value.clear();
    int separatorCheck = -1;
    while (!matchSymbol(']')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseOctopusComponent((value.emplace_back(), value.back())))
            return error;
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusLibrary(octopus::Library &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (key == "id") {
            if (Error error = parseStdString(value.id))
                return error;
        } else if (key == "name") {
            if (Error error = parseStdString(value.name))
                return error;
        } else if (key == "children") {
            if (Error error = parseStdVectorOctopusReference(value.children))
                return error;
        } else if (key == "location") {
            if (Error error = parseNonstdOptionalOctopusResourceLocation(value.location))
                return error;
        } else if (key == "preview") {
            if (Error error = parseNonstdOptionalOctopusResourceLocation(value.preview))
                return error;
        } else if (key == "assets") {
            if (Error error = parseNonstdOptionalOctopusAssets(value.assets))
                return error;
        } else if (key == "description") {
            if (Error error = parseNonstdOptionalStdString(value.description))
                return error;
        } else if (key == "hash") {
            if (Error error = parseNonstdOptionalStdString(value.hash))
                return error;
        } else {
            if (Error error = skipValue())
                return error;
        }
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseStdVectorOctopusLibrary(std::vector<octopus::Library> &value) {
    if (!matchSymbol('['))
        return ErrorType::TYPE_MISMATCH;
    value.clear();
    int separatorCheck = -1;
    while (!matchSymbol(']')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseOctopusLibrary((value.emplace_back(), value.back())))
            return error;
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusChunkType(octopus::Chunk::Type &value) {
    std::string str;
    if (ErrorType error = parseStdString(str))
        return error;
    if (str == "STYLE_LAYER")
        value = octopus::Chunk::Type::STYLE_LAYER;
    else if (str == "STYLE_FILL")
        value = octopus::Chunk::Type::STYLE_FILL;
    else if (str == "STYLE_TEXT")
        value = octopus::Chunk::Type::STYLE_TEXT;
    else if (str == "STYLE_EFFECT")
        value = octopus::Chunk::Type::STYLE_EFFECT;
    else if (str == "STYLE_GRID")
        value = octopus::Chunk::Type::STYLE_GRID;
    else
        return ErrorType::UNKNOWN_ENUM_VALUE;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusChunk(octopus::Chunk &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (key == "id") {
            if (Error error = parseStdString(value.id))
                return error;
        } else if (key == "name") {
            if (Error error = parseStdString(value.name))
                return error;
        } else if (key == "type") {
            if (Error error = parseOctopusChunkType(value.type))
                return error;
        } else if (key == "location") {
            if (Error error = parseOctopusResourceLocation(value.location))
                return error;
        } else if (key == "artifacts") {
            if (Error error = parseStdVectorOctopusArtifact(value.artifacts))
                return error;
        } else if (key == "preview") {
            if (Error error = parseNonstdOptionalOctopusResourceLocation(value.preview))
                return error;
        } else if (key == "assets") {
            if (Error error = parseNonstdOptionalOctopusAssets(value.assets))
                return error;
        } else if (key == "description") {
            if (Error error = parseNonstdOptionalStdString(value.description))
                return error;
        } else if (key == "hash") {
            if (Error error = parseNonstdOptionalStdString(value.hash))
                return error;
        } else if (key == "status") {
            if (Error error = parseNonstdOptionalOctopusStatus(value.status))
                return error;
        } else {
            if (Error error = skipValue())
                return error;
        }
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseStdVectorOctopusChunk(std::vector<octopus::Chunk> &value) {
    if (!matchSymbol('['))
        return ErrorType::TYPE_MISMATCH;
    value.clear();
    int separatorCheck = -1;
    while (!matchSymbol(']')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseOctopusChunk((value.emplace_back(), value.back())))
            return error;
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

ManifestParser::ErrorType ManifestParser::parseOctopusOctopusManifest(octopus::OctopusManifest &value) {
    std::string key;
    if (!matchSymbol('{'))
        return ErrorType::TYPE_MISMATCH;
    int separatorCheck = -1;
    while (!matchSymbol('}')) {
        if (!separatorCheck)
            return ErrorType::JSON_SYNTAX_ERROR;
        if (ErrorType error = parseStdString(key))
            return error;
        if (!matchSymbol(':'))
            return ErrorType::JSON_SYNTAX_ERROR;
        if (key == "version") {
            if (Error error = parseStdString(value.version))
                return error;
        } else if (key == "origin") {
            if (Error error = parseOctopusOctopusManifestOrigin(value.origin))
                return error;
        } else if (key == "name") {
            if (Error error = parseStdString(value.name))
                return error;
        } else if (key == "pages") {
            if (Error error = parseStdVectorOctopusPage(value.pages))
                return error;
        } else if (key == "components") {
            if (Error error = parseStdVectorOctopusComponent(value.components))
                return error;
        } else if (key == "libraries") {
            if (Error error = parseStdVectorOctopusLibrary(value.libraries))
                return error;
        } else if (key == "chunks") {
            if (Error error = parseStdVectorOctopusChunk(value.chunks))
                return error;
        } else if (key == "resourcesBase") {
            if (Error error = parseStdString(value.resourcesBase))
                return error;
        } else if (key == "interactions") {
            if (Error error = parseNonstdOptionalOctopusResourceLocation(value.interactions))
                return error;
        } else if (key == "hash") {
            if (Error error = parseNonstdOptionalStdString(value.hash))
                return error;
        } else {
            if (Error error = skipValue())
                return error;
        }
        separatorCheck = matchSymbol(',');
    }
    if (separatorCheck == 1)
        return ErrorType::JSON_SYNTAX_ERROR;
    return ErrorType::OK;
}

}
